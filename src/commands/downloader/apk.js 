import axios from 'axios';

const PLAYSTORE_TIMEOUT = 15000; // 15s for fetch
const REPLY_TIMEOUT = 300000; // 5 min for next search

export default {
    name: 'apk',
    aliases: ['playstore', 'app', 'apps'],
    category: 'search',
    description: 'Search for APK apps on Play Store',
    usage: 'apk <query>',
    example: 'apk Suno Ai',
    cooldown: 5,
    permissions: ['user'],
    supportsReply: true,
    args: true,
    minArgs: 1,

    async execute({ sock, message, args, from, sender, prefix }) {
        const query = args.join(' ').trim();

        if (!query) {
            return await sock.sendMessage(from, {
                text: `â•­â”€â”€â¦¿ã€ ğŸ“± PLAY STORE SEARCH ã€‘
â”‚
â”‚ ğŸ’¡ ğ—¨ğ˜€ğ—®ğ—´ğ—²:
â”‚    ${prefix}apk <app name>
â”‚
â”‚ ğŸ“ ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²ğ˜€:
â”‚    ${prefix}apk Suno Ai
â”‚    ${prefix}apk whatsapp
â”‚    ${prefix}apk instagram
â”‚
â”‚ ğŸ”„ ğ—¡ğ—²ğ˜…ğ˜ ğ—¦ğ—²ğ—®ğ—¿ğ—°ğ—µ:
â”‚    Reply to results with new query
â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â¦¿`
            }, { quoted: message });
        }

        try {
            await sock.sendMessage(from, {
                react: { text: 'ğŸ”', key: message.key }
            });

            const statusMsg = await sock.sendMessage(from, {
                text: `â³ Searching Play Store for "${query}"...`
            }, { quoted: message });

            const apiUrl = `https://arychauhann.onrender.com/api/playstore?query=${encodeURIComponent(query)}`;
            const { data } = await axios.get(apiUrl, {
                timeout: PLAYSTORE_TIMEOUT,
                headers: {
                    'User-Agent': 'Mozilla/5.0'
                }
            });

            const apps = data.data || [];
            if (apps.length === 0) {
                await sock.sendMessage(from, {
                    text: `âŒ No apps found for "${query}"`,
                    edit: statusMsg.key
                }, { quoted: message });
                return;
            }

            // Assume app structure: { name, developer, icon, score, installs, apk: 'download_url' }
            const firstApp = apps[0];
            const name = firstApp.name || 'Unknown App';
            const developer = firstApp.developer || 'Unknown Developer';
            const score = firstApp.score ? `${firstApp.score}/5` : 'N/A';
            const installs = firstApp.installs || 'N/A';
            const iconUrl = firstApp.icon || '';
            const apkUrl = firstApp.apk || firstApp.download || '';

            let caption = `ğŸ“± *${name}*\n\nğŸ‘¨â€ğŸ’» Developer: ${developer}\nâ­ Rating: ${score}\nğŸ“¥ Installs: ${installs}\n\n`;
            if (apkUrl) {
                caption += `ğŸ”— Download APK: ${apkUrl}\n`;
            }
            caption += `\nFound ${apps.length} apps.\nğŸ’¡ Reply for new search!`;

            const sentMsg = await sock.sendMessage(from, {
                image: { url: iconUrl },
                caption
            }, { quoted: message });

            // Send remaining app icons if more
            for (let i = 1; i < apps.length; i++) {
                const app = apps[i];
                await sock.sendMessage(from, {
                    image: { url: app.icon || '' },
                    caption: `ğŸ“± ${app.name || 'App'}\nğŸ‘¨â€ğŸ’» ${app.developer || 'Dev'}\nâ­ ${app.score ? `${app.score}/5` : 'N/A'}`
                }, { quoted: sentMsg });
            }

            await sock.sendMessage(from, {
                react: { text: 'âœ…', key: message.key }
            });

            if (sentMsg && sentMsg.key && sentMsg.key.id) {
                this.setupReplyListener(sock, from, sentMsg.key.id, query, sender, prefix);
            }

        } catch (error) {
            console.error('APK command error:', error);

            const errorMsg = error.code === 'ECONNABORTED'
                ? 'Search timeout'
                : error.response?.status === 429
                ? 'Rate limit - wait a bit'
                : error.message || 'Failed to search apps';

            await sock.sendMessage(from, {
                text: `â•­â”€â”€â¦¿ã€ âŒ ERROR ã€‘
â”‚
â”‚ âš ï¸ Play Store search failed
â”‚
â”‚ ğŸ“ Error: ${errorMsg}
â”‚
â”‚ ğŸ”„ Try again
â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â¦¿`
            }, { quoted: message });

            await sock.sendMessage(from, {
                react: { text: 'âŒ', key: message.key }
            });
        }
    },

    setupReplyListener(sock, from, messageId, originalQuery, authorizedSender, prefix) {
        if (!global.replyHandlers) {
            global.replyHandlers = {};
        }

        const existingHandler = global.replyHandlers[messageId];
        if (existingHandler && existingHandler.timeout) {
            clearTimeout(existingHandler.timeout);
        }

        const replyTimeout = setTimeout(() => {
            if (global.replyHandlers && global.replyHandlers[messageId]) {
                delete global.replyHandlers[messageId];
            }
        }, REPLY_TIMEOUT);

        global.replyHandlers[messageId] = {
            command: this.name,
            authorizedSender: authorizedSender,
            originalQuery: originalQuery,
            timeout: replyTimeout,
            handler: async (replyText, replyMessage) => {
                const replySender = replyMessage.key.participant || replyMessage.key.remoteJid;
                
                if (replySender !== authorizedSender) {
                    return;
                }

                const newQuery = replyText.trim();
                const searchQuery = newQuery || originalQuery;

                try {
                    await sock.sendMessage(from, {
                        react: { text: 'ğŸ”', key: replyMessage.key }
                    });

                    const statusMsg = await sock.sendMessage(from, {
                        text: `â³ Searching Play Store for "${searchQuery}"...`
                    }, { quoted: replyMessage });

                    const apiUrl = `https://arychauhann.onrender.com/api/playstore?query=${encodeURIComponent(searchQuery)}`;
                    const { data } = await axios.get(apiUrl, {
                        timeout: PLAYSTORE_TIMEOUT,
                        headers: {
                            'User-Agent': 'Mozilla/5.0'
                        }
                    });

                    const apps = data.data || [];
                    if (apps.length === 0) {
                        await sock.sendMessage(from, {
                            text: `âŒ No apps found for "${searchQuery}"`,
                            edit: statusMsg.key
                        }, { quoted: replyMessage });
                        return;
                    }

                    const firstApp = apps[0];
                    const name = firstApp.name || 'Unknown App';
                    const developer = firstApp.developer || 'Unknown Developer';
                    const score = firstApp.score ? `${firstApp.score}/5` : 'N/A';
                    const installs = firstApp.installs || 'N/A';
                    const iconUrl = firstApp.icon || '';
                    const apkUrl = firstApp.apk || firstApp.download || '';

                    let caption = `ğŸ“± *${name}*\n\nğŸ‘¨â€ğŸ’» Developer: ${developer}\nâ­ Rating: ${score}\nğŸ“¥ Installs: ${installs}\n\n`;
                    if (apkUrl) {
                        caption += `ğŸ”— Download APK: ${apkUrl}\n`;
                    }
                    caption += `\nFound ${apps.length} apps.\nğŸ’¡ Reply for new search!`;

                    const newSentMsg = await sock.sendMessage(from, {
                        image: { url: iconUrl },
                        caption
                    }, { quoted: replyMessage });

                    for (let i = 1; i < apps.length; i++) {
                        const app = apps[i];
                        await sock.sendMessage(from, {
                            image: { url: app.icon || '' },
                            caption: `ğŸ“± ${app.name || 'App'}\nğŸ‘¨â€ğŸ’» ${app.developer || 'Dev'}\nâ­ ${app.score ? `${app.score}/5` : 'N/A'}`
                        }, { quoted: newSentMsg });
                    }

                    await sock.sendMessage(from, {
                        react: { text: 'âœ…', key: replyMessage.key }
                    });

                    clearTimeout(replyTimeout);
                    delete global.replyHandlers[messageId];

                    if (newSentMsg && newSentMsg.key && newSentMsg.key.id) {
                        this.setupReplyListener(sock, from, newSentMsg.key.id, searchQuery, authorizedSender, prefix);
                    }

                } catch (error) {
                    console.error('APK reply error:', error);

                    const errorMsg = error.code === 'ECONNABORTED'
                        ? 'Search timeout'
                        : error.response?.status === 429
                        ? 'Rate limit exceeded'
                        : error.message || 'Unknown error';

                    await sock.sendMessage(from, {
                        text: `âŒ Failed to search: ${errorMsg}\nTry again!`
                    }, { quoted: replyMessage });

                    await sock.sendMessage(from, {
                        react: { text: 'âŒ', key: replyMessage.key }
                    });

                    clearTimeout(replyTimeout);
                    delete global.replyHandlers[messageId];
                }
            }
        };
    }
};